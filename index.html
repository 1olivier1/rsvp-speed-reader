<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>RSVP Prototype</title>

  <!-- PDF.js (for PDF text extraction in-browser) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.js"></script>

  <style>
    :root{
      --bg: #0b0f14;
      --panel: #0f1620;
      --text: #e7eef8;
      --muted: #9fb0c3;
      --pivot: #ff4d6d;
      --tick: rgba(231, 238, 248, 0.55);
      --border: rgba(231, 238, 248, 0.12);
    }

    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background: radial-gradient(1200px 600px at 50% 25%, #111c2b, var(--bg));
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    .app{
      width:min(900px, 92vw);
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    /* Focus box */
    .focus-box{
      position: relative;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 34px 22px;
      height: 150px;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow: 0 16px 40px rgba(0,0,0,0.35);
      overflow: hidden;
    }

    /* Reticle ticks (above and below the pivot center line) */
    .focus-box::before,
    .focus-box::after{
      content:"";
      position:absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 14px;
      border-left: 2px solid var(--tick);
    }
    .focus-box::before{ top: 18px; }
    .focus-box::after{ bottom: 18px; }

    /*
      KEY ALIGNMENT:
      3-column grid: [prefix | pivot | suffix]
      - prefix expands left (1fr) and is right-aligned
      - pivot is auto-width and stays centered
      - suffix expands right (1fr) and is left-aligned
    */
    .wordline{
      width: 100%;
      max-width: 720px;
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      align-items:baseline;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "JetBrains Mono", "Courier New", monospace;
      font-size: clamp(34px, 5vw, 54px);
      line-height: 1.05;
      letter-spacing: 0.5px;
      font-variant-ligatures: none;
    }

    .prefix{
      justify-self: end;
      text-align: right;
      color: var(--text);
      opacity: 0.95;
      white-space: pre;
    }

    .pivot{
      justify-self: center;
      color: var(--pivot);
      font-weight: 700;
      padding: 0 2px;
      white-space: pre;
      text-shadow: 0 0 14px rgba(255,77,109,0.25);
    }

    .suffix{
      justify-self: start;
      text-align: left;
      color: var(--text);
      opacity: 0.95;
      white-space: pre;
    }

    .controls{
      background: rgba(15,22,32,0.65);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 14px;
      display:grid;
      gap: 12px;
    }

    textarea{
      width: 100%;
      min-height: 140px;
      resize: vertical;
      background: rgba(0,0,0,0.28);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px 12px;
      color: var(--text);
      font-size: 14px;
      line-height: 1.4;
      outline: none;
    }

    textarea:focus{
      border-color: rgba(255,255,255,0.22);
    }

    .row{
      display:flex;
      gap: 12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap: wrap;
    }

    button{
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px 14px;
      font-weight: 600;
      cursor:pointer;
      transition: transform 0.05s ease, background 0.15s ease;
    }
    button:hover{ background: rgba(255,255,255,0.10); }
    button:active{ transform: scale(0.98); }

    .wpm{
      display:flex;
      align-items:center;
      gap: 10px;
      flex: 1;
      min-width: 260px;
    }

    input[type="range"]{
      width: 100%;
      accent-color: var(--pivot);
    }

    .meta{
      color: var(--muted);
      font-size: 13px;
    }

    .badge{
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      font-size: 12px;
      color: var(--muted);
    }

    /* Slightly nicer file input without over-styling */
    input[type="file"]{
      color: var(--muted);
      max-width: 100%;
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="focus-box" aria-label="RSVP focus box">
      <div class="wordline" aria-live="polite">
        <span class="prefix" id="prefix"></span>
        <span class="pivot" id="pivot"></span>
        <span class="suffix" id="suffix"></span>
      </div>
    </div>

    <div class="controls">

      <!-- File upload row (TXT + PDF) -->
      <div class="row">
        <input id="fileInput" type="file"
               accept=".txt,.pdf,application/pdf,text/plain"
               multiple />
        <button id="loadFiles">Load file(s)</button>
        <div class="meta" id="fileStatus">No files loaded</div>
      </div>

      <textarea id="input" placeholder="Paste text here...">This is an RSVP prototype. Notice how the highlighted letter stays perfectly centered, even for longer words. Cool; right?</textarea>

      <div class="row">
        <button id="toggle">Play</button>
        <button id="reset">Reset</button>

        <div class="wpm">
          <span class="badge">WPM: <strong id="wpmLabel">400</strong></span>
          <input id="wpm" type="range" min="200" max="1000" value="400" />
        </div>

        <div class="meta" id="status">Paused • 0/0</div>
      </div>
    </div>
  </div>

  <script>
    // ---- Pivot math (Optimal Recognition Point) ----
    function pivotIndex(word) {
      const n = word.length;
      if (n <= 1) return 0;            // 1st letter (0-based)
      if (n >= 2 && n <= 5) return 1;  // 2nd
      if (n >= 6 && n <= 9) return 2;  // 3rd
      if (n >= 10 && n <= 13) return 3;// 4th
      return 4;                        // 5th
    }

    function splitWord(word) {
      const idx = Math.min(pivotIndex(word), Math.max(0, word.length - 1));
      return {
        prefix: word.slice(0, idx),
        pivot:  word[idx] ?? "",
        suffix: word.slice(idx + 1)
      };
    }

    function endsWithDelayPunct(word) {
      // 2x delay for words ending in ., ?, !, or ;
      return /[.?!;]$/.test(word);
    }

    function tokenize(text) {
      return text
        .replace(/\s+/g, " ")
        .trim()
        .split(" ")
        .filter(Boolean);
    }

    // ---- DOM ----
    const elPrefix = document.getElementById("prefix");
    const elPivot  = document.getElementById("pivot");
    const elSuffix = document.getElementById("suffix");

    const elInput  = document.getElementById("input");
    const elToggle = document.getElementById("toggle");
    const elReset  = document.getElementById("reset");
    const elWpm    = document.getElementById("wpm");
    const elWpmLbl = document.getElementById("wpmLabel");
    const elStatus = document.getElementById("status");

    const elFileInput  = document.getElementById("fileInput");
    const elLoadFiles  = document.getElementById("loadFiles");
    const elFileStatus = document.getElementById("fileStatus");

    // ---- Player state ----
    let words = tokenize(elInput.value);
    let i = 0;
    let playing = false;
    let timerId = null;

    function baseDelayMs() {
      const wpm = Number(elWpm.value);
      return 60000 / wpm;
    }

    function renderWord(word) {
      const parts = splitWord(word);
      elPrefix.textContent = parts.prefix;
      elPivot.textContent  = parts.pivot;
      elSuffix.textContent = parts.suffix;
    }

    function updateStatus() {
      const total = words.length;
      elStatus.textContent = `${playing ? "Playing" : "Paused"} • ${Math.min(i, total)}/${total}`;
    }

    function clearTimer() {
      if (timerId !== null) {
        clearTimeout(timerId);
        timerId = null;
      }
    }

    // Core timer loop (setTimeout, not setInterval) so WPM changes apply instantly.
    function tick() {
      if (!playing) return;

      if (words.length === 0) {
        playing = false;
        elToggle.textContent = "Play";
        renderWord("");
        updateStatus();
        return;
      }

      if (i >= words.length) {
        playing = false;
        elToggle.textContent = "Play";
        updateStatus();
        return;
      }

      const word = words[i];
      renderWord(word);
      updateStatus();

      let delay = baseDelayMs();
      if (endsWithDelayPunct(word)) delay *= 2;

      i += 1;

      clearTimer();
      timerId = setTimeout(tick, delay);
    }

    function play() {
      words = tokenize(elInput.value);
      if (i >= words.length) i = 0;
      playing = true;
      elToggle.textContent = "Pause";
      updateStatus();
      tick();
    }

    function pause() {
      playing = false;
      elToggle.textContent = "Play";
      clearTimer();
      updateStatus();
    }

    function reset() {
      pause();
      i = 0;
      words = tokenize(elInput.value);
      renderWord(words[0] || "");
      updateStatus();
    }

    // ---- PDF/TXT reading ----
    // Configure PDF.js worker
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.js";
    }

    async function readTextFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(String(reader.result || ""));
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file);
      });
    }

    async function readPdfFile(file) {
      const buffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: buffer }).promise;

      let text = "";
      for (let p = 1; p <= pdf.numPages; p++) {
        const page = await pdf.getPage(p);
        const content = await page.getTextContent();
        text += content.items.map(it => it.str).join(" ") + "\n\n";
      }
      return text.trim();
    }

    async function readAnyFile(file) {
      const name = (file.name || "").toLowerCase();
      if (name.endsWith(".pdf") || file.type === "application/pdf") {
        return await readPdfFile(file);
      }
      return await readTextFile(file);
    }

    // ---- Events ----
    elToggle.addEventListener("click", () => {
      if (playing) pause();
      else play();
    });

    elReset.addEventListener("click", reset);

    elWpm.addEventListener("input", () => {
      elWpmLbl.textContent = elWpm.value;
      // If playing, next tick uses new delay automatically.
    });

    elInput.addEventListener("input", () => {
      if (!playing) {
        i = 0;
        words = tokenize(elInput.value);
        renderWord(words[0] || "");
        updateStatus();
      }
    });

    // Load file(s) button
    elLoadFiles.addEventListener("click", async () => {
      const files = Array.from(elFileInput.files || []);
      if (!files.length) return;

      elFileStatus.textContent = "Loading...";

      try {
        const contents = await Promise.all(files.map(readAnyFile));
        elInput.value = contents.join("\n\n");

        elFileStatus.textContent = `Loaded: ${files.map(f => f.name).join(", ")}`;

        // Reset reading position + preview first word
        i = 0;
        words = tokenize(elInput.value);
        renderWord(words[0] || "");
        updateStatus();
      } catch (err) {
        console.error(err);
        elFileStatus.textContent = "Failed to read files";
      }
    });

    // Init
    elWpmLbl.textContent = elWpm.value;
    reset();
  </script>
</body>
</html>
